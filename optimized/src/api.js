class NocturneAPI{constructor(){this.baseURLs ={jupiter: 'https: solana: 'https: coinGecko: 'https: birdeye: 'https:};this.cache = new Map();this.cacheExpiry = 30000;this.retryAttempts = 3;this.retryDelay = 1000;console.log('🔌 NocturneSwap API layer initialized');}async apiCall(url,options ={}){const startTime = Date.now();for(let attempt = 1;attempt <= this.retryAttempts;attempt++){try{const response = await fetch(url,{...options,headers:{'Content-Type': 'application/json',...options.headers}});const duration = Date.now()- startTime;if(!response.ok){throw new Error(`HTTP ${response.status}: ${response.statusText}`);}const data = await response.json();if(window.analytics){window.analytics.trackApiCall(url,duration,true);}return data;}catch(error){console.warn(`API call attempt ${attempt}failed:`,error.message);if(attempt === this.retryAttempts){const duration = Date.now()- startTime;if(window.analytics){window.analytics.trackApiCall(url,duration,false);}throw new Error(`API call failed after ${this.retryAttempts}attempts: ${error.message}`);}await new Promise(resolve => setTimeout(resolve,this.retryDelay * attempt));}}}getCachedData(key){const cached = this.cache.get(key);if(cached && Date.now()- cached.timestamp < this.cacheExpiry){return cached.data;}return null;}setCachedData(key,data){this.cache.set(key,{data: data,timestamp: Date.now()});}async getJupiterQuote(inputMint,outputMint,amount,slippageBps = 50){const cacheKey = `quote_${inputMint}_${outputMint}_${amount}_${slippageBps}`;const cached = this.getCachedData(cacheKey);if(cached)return cached;try{const params = new URLSearchParams({inputMint,outputMint,amount,slippageBps,onlyDirectRoutes: 'false',asLegacyTransaction: 'false'});const url = `${this.baseURLs.jupiter}/quote?${params}`;const quote = await this.apiCall(url);this.setCachedData(cacheKey,quote);return quote;}catch(error){console.error('❌ Jupiter quote failed:',error);throw error;}}async getJupiterSwapTransaction(quoteResponse,userPublicKey,priorityFee = 0){try{const url = `${this.baseURLs.jupiter}/swap`;const swapTransaction = await this.apiCall(url,{method: 'POST',body: JSON.stringify({quoteResponse,userPublicKey,priorityFee})});return swapTransaction;}catch(error){console.error('❌ Jupiter swap transaction failed:',error);throw error;}}async getTokenList(){const cacheKey = 'token_list';const cached = this.getCachedData(cacheKey);if(cached)return cached;try{const url = 'https: const tokens = await this.apiCall(url);const popularTokens = tokens.filter(token => token.daily_volume > 100000 || ['SOL','USDC','USDT','RAY','SRM','ORCA','MNGO'].includes(token.symbol));this.setCachedData(cacheKey,popularTokens);return popularTokens;}catch(error){console.error('❌ Token list fetch failed:',error);return this.getFallbackTokenList();}}getFallbackTokenList(){return [{symbol: 'SOL',name: 'Solana',address: 'So11111111111111111111111111111111111111112',decimals: 9,logoURI: 'https:},{symbol: 'USDC',name: 'USD Coin',address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',decimals: 6,logoURI: 'https:},{symbol: 'USDT',name: 'Tether USD',address: 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB',decimals: 6,logoURI: 'https:}];}async getTokenPrices(tokenIds){const cacheKey = `prices_${tokenIds.join('_')}`;const cached = this.getCachedData(cacheKey);if(cached)return cached;try{const params = new URLSearchParams({ids: tokenIds.join(','),vs_currencies: 'usd',include_24hr_change: 'true',include_24hr_vol: 'true'});const url = `${this.baseURLs.coinGecko}/simple/price?${params}`;const prices = await this.apiCall(url);this.setCachedData(cacheKey,prices);return prices;}catch(error){console.error('❌ Price fetch failed:',error);return this.getMockPrices(tokenIds);}}getMockPrices(tokenIds){const mockPrices ={'solana':{usd: 142.35,usd_24h_change: 2.34,usd_24h_vol: 1234567890},'usd-coin':{usd: 1.00,usd_24h_change: 0.01,usd_24h_vol: 9876543210},'tether':{usd: 1.00,usd_24h_change: -0.01,usd_24h_vol: 8765432109}};const result ={};tokenIds.forEach(id =>{result[id] = mockPrices[id] ||{usd: Math.random()* 100,usd_24h_change:(Math.random()- 0.5)* 20,usd_24h_vol: Math.random()* 1000000};});return result;}async getMarketStats(){const cacheKey = 'market_stats';const cached = this.getCachedData(cacheKey);if(cached)return cached;try{const globalUrl = `${this.baseURLs.coinGecko}/global/decentralized_finance_defi`;const globalStats = await this.apiCall(globalUrl);const solanaUrl = `${this.baseURLs.coinGecko}/coins/solana`;const solanaStats = await this.apiCall(solanaUrl);const stats ={totalMarketCap: globalStats.data.defi_market_cap,totalVolume: globalStats.data.trading_volume_24h,defiDominance: globalStats.data.defi_dominance,solanaPrice: solanaStats.market_data.current_price.usd,solanaVolume: solanaStats.market_data.total_volume.usd,solanaMarketCap: solanaStats.market_data.market_cap.usd};this.setCachedData(cacheKey,stats);return stats;}catch(error){console.error('❌ Market stats fetch failed:',error);return this.getMockMarketStats();}}getMockMarketStats(){return{totalMarketCap: 89234567890,totalVolume: 12345678901,defiDominance: 7.8,solanaPrice: 142.35,solanaVolume: 1234567890,solanaMarketCap: 58901234567};}async getPoolData(poolAddress){const cacheKey = `pool_${poolAddress}`;const cached = this.getCachedData(cacheKey);if(cached)return cached;try{const mockPoolData ={address: poolAddress,tokenA:{symbol: 'SOL',reserve: 1234.56},tokenB:{symbol: 'USDC',reserve: 175689.23},fee: 0.3,apy: 12.45,volume24h: 567890.12,liquidity: 351378.46};this.setCachedData(cacheKey,mockPoolData);return mockPoolData;}catch(error){console.error('❌ Pool data fetch failed:',error);throw error;}}async getTransactionHistory(walletAddress,limit = 50){const cacheKey = `history_${walletAddress}_${limit}`;const cached = this.getCachedData(cacheKey);if(cached)return cached;try{const mockTransactions = Array.from({length: Math.min(limit,10)},(_,i)=>({signature: `${Math.random().toString(36).substr(2,9)}`,slot: 200000000 + i,timestamp: Date.now()-(i * 300000),type: Math.random()> 0.5 ? 'swap' : 'transfer',status: Math.random()> 0.1 ? 'success' : 'failed',fromToken: 'SOL',toToken: 'USDC',fromAmount:(Math.random()* 10).toFixed(4),toAmount:(Math.random()* 1000).toFixed(2),fee:(Math.random()* 0.01).toFixed(6)}));this.setCachedData(cacheKey,mockTransactions);return mockTransactions;}catch(error){console.error('❌ Transaction history fetch failed:',error);throw error;}}async getPortfolioAnalytics(walletAddress){const cacheKey = `portfolio_${walletAddress}`;const cached = this.getCachedData(cacheKey);if(cached)return cached;try{const mockPortfolio ={totalValue: 12345.67,totalPnL: 1234.56,totalPnLPercent: 11.11,tokens: [{symbol: 'SOL',amount: 45.67,value: 6543.21,pnl: 654.32},{symbol: 'USDC',amount: 5678.90,value: 5678.90,pnl: 0},{symbol: 'RAY',amount: 123.45,value: 123.56,pnl: -12.34}],performance:{'1d': 2.34,'7d': 12.45,'30d': 23.45,'1y': 145.67}};this.setCachedData(cacheKey,mockPortfolio);return mockPortfolio;}catch(error){console.error('❌ Portfolio analytics fetch failed:',error);throw error;}}startPriceStream(tokens,callback){const ws = new WebSocket('wss: ws.onopen =()=>{console.log('🔄 Price stream connected');const streams = tokens.map(token => `${token.toLowerCase()}usdt@ticker`);const subscription ={method: 'SUBSCRIBE',params: streams,id: 1};ws.send(JSON.stringify(subscription));};ws.onmessage =(event)=>{try{const data = JSON.parse(event.data);if(data.data && data.data.c){callback({symbol: data.data.s,price: parseFloat(data.data.c),change: parseFloat(data.data.P),volume: parseFloat(data.data.v)});}}catch(error){console.error('❌ Price stream error:',error);}};ws.onerror =(error)=>{console.error('❌ WebSocket error:',error);};ws.onclose =()=>{console.log('🔄 Price stream disconnected');setTimeout(()=> this.startPriceStream(tokens,callback),5000);};return ws;}async healthCheck(){const services = [{name: 'Jupiter API',url: `${this.baseURLs.jupiter}/quote?inputMint=So11111111111111111111111111111111111111112&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=1000000000`},{name: 'CoinGecko API',url: `${this.baseURLs.coinGecko}/simple/price?ids=solana&vs_currencies=usd`},{name: 'Solana RPC',url: this.baseURLs.solana,method: 'POST',body: JSON.stringify({jsonrpc: '2.0',id: 1,method: 'getHealth'})}];const results = await Promise.allSettled(services.map(async(service)=>{const start = Date.now();try{await this.apiCall(service.url,{method: service.method || 'GET',body: service.body});return{name: service.name,status: 'healthy',responseTime: Date.now()- start};}catch(error){return{name: service.name,status: 'unhealthy',error: error.message,responseTime: Date.now()- start};}}));return results.map(result => result.value);}}let nocturneAPI;if(typeof window !== 'undefined'){nocturneAPI = new NocturneAPI();window.NocturneAPI = nocturneAPI;console.log('🔌 NocturneSwap API layer ready');}if(typeof module !== 'undefined' && module.exports){module.exports ={NocturneAPI};}